# Copyright 2018 John Harwell, All rights reserved.
#
#  This file is part of SIERRA.
#
#  SIERRA is free software: you can redistribute it and/or modify it under the
#  terms of the GNU General Public License as published by the Free Software
#  Foundation, either version 3 of the License, or (at your option) any later
#  version.
#
#  SIERRA is distributed in the hope that it will be useful, but WITHOUT ANY
#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
#  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along with
#  SIERRA.  If not, see <http://www.gnu.org/licenses/
"""
Experiment creation classes, taking an experiment definition `generated` by
classes in ``exp_generators.py`` and writing the experiment to the filesystem.

"""

# Core packages
import os
import random
import typing as tp
import shutil
import logging  # type: tp.Any

# 3rd party packages

# Project packages
from sierra.core.xml import XMLLuigi
from sierra.core.variables import batch_criteria as bc
import sierra.core.config as config
import sierra.core.utils
import sierra.core.plugin_manager as pm
from sierra.core import types
from sierra.core.generators.exp_generators import BatchExpDefGenerator
from sierra.core import platform


class ExpCreator:
    """
    Instantiate an experiment within a batch from an experiment definition
    generated by
    :class:`~sierra.core.generators.exp_generators.BatchExpDefGenerator` by
    writing out run input files and setting up the necessary directory
    structure.

    Attributes: template_input_file: Path(relative to current dir or absolute)
        to the template XML configuration file.

        exp_input_root: Absolute path to experiment directory where generated
                         XML input files for this experiment should be written.

        exp_output_root: Absolute path to root directory for run outputs
                         for this experiment (sort of a scratch directory).

        cmdopts: Dictionary containing parsed cmdline options.

    """

    def __init__(self,
                 template_input_file: str,
                 exp_input_root: str,
                 exp_output_root: str,
                 cmdopts: types.Cmdopts) -> None:

        # Will get the main name and extension of the config file (without the
        # full absolute path)
        self.main_input_name, self.main_input_extension = os.path.splitext(
            os.path.basename(os.path.abspath(template_input_file)))

        # where the generated config and command files should be stored
        self.exp_input_root = os.path.abspath(exp_input_root)

        self.exp_output_root = os.path.abspath(exp_output_root)
        self.cmdopts = cmdopts

        self.random_seed_min = 1
        self.random_seed_max = 10 * self.cmdopts["n_runs"]

        # where the commands file will be stored
        self.commands_fpath = os.path.abspath(os.path.join(self.exp_input_root,
                                                           config.kGNUParallel['cmdfile']))

    def from_def(self, exp_def: XMLLuigi):
        """
        Given a :class:`~sierra.core.xml.XMLLuigi` object containing all changes
        that should be made to all runs in the experiment, create additional
        changes to create a set of unique runs from which distributions of swarm
        behavior can be meaningfully computed post-hoc.

        Writes out all experiment input files to the filesystem.

        """
        seeds = self._generate_random_seeds()

        # Clear out commands file if it exists
        if sierra.core.utils.path_exists(self.commands_fpath):
            os.remove(self.commands_fpath)

        # Create all experimental runs
        for run_num in range(self.cmdopts['n_runs']):
            self._create_exp_run(exp_def, run_num, seeds)

    def _create_exp_run(self, exp_def: XMLLuigi, run_num: int, seeds) -> None:
        run_output_dir = "{0}_{1}_output".format(self.main_input_name,
                                                 run_num)

        # If the project defined per-run configuration, apply
        # it. Otherwise, just apply the configuration in the SIERRA core.
        per_run = pm.module_load_tiered(project=self.cmdopts['project'],
                                        path='generators.exp_generators')

        per_run.ExpRunDefUniqueGenerator(run_num,
                                         self.exp_output_root,
                                         run_output_dir,
                                         self.cmdopts).generate(exp_def, seeds)

        # Write out the experimental run launch file
        save_path = self._get_launch_file_path(run_num)
        open(save_path, 'w').close()  # create an empty file
        exp_def.write(save_path)

        # If visual capture is enabled perform any necessary per-run
        # configuration needed.
        if self.cmdopts['platform_vc']:
            run_output_dir = os.path.join(self.exp_output_root,
                                          run_output_dir)
            platform.ExpRunVCConfigurer(self.cmdopts['platform'])(self.cmdopts,
                                                                  run_output_dir)

        # Update GNU Parallel commands file with the command for the configured
        # experimental run.
        with open(self.commands_fpath, 'a') as cmds_file:
            self._update_cmds_file(cmds_file,
                                   self._get_launch_file_path(run_num))

    def _get_launch_file_path(self, run_num: int) -> str:
        """
        File is named as ``<template input file stem>_<run_num>`` in the
        experiment generation root.
        """
        return os.path.join(self.exp_input_root,
                            "{0}_{1}".format(self.main_input_name, run_num))

    def _update_cmds_file(self, cmds_file, run_input_path: str) -> None:
        """
        Adds the command to launch a particular experimental run to the command
        file.
        """
        launch_generator = platform.LaunchCmdGenerator()
        launch_cmd = launch_generator(self.cmdopts['platform'],
                                      self.cmdopts['exec_env'],
                                      run_input_path)

        lvc_generator = platform.LaunchWithVCCmdGenerator()
        launch_with_vc_cmd = lvc_generator(self.cmdopts, launch_cmd)

        cmds_file.write(launch_with_vc_cmd + '\n')

    def _generate_random_seeds(self):
        """Generates random seeds for experiments to use."""
        try:
            return random.sample(range(self.random_seed_min, self.random_seed_max + 1),
                                 self.cmdopts["n_runs"])
        except ValueError as ve:
            # create a new error message that clarifies the previous one
            raise ValueError(
                "# seeds < # runs: change the random seed parameters") from ve


class BatchExpCreator:
    """
    Instantiate a batch experiment from a list of experiment definitions, as
    generated by
    :class:`~sierra.core.generators.exp_generators.BatchExpDefGenerator`, by
    invoking :class:`~sierra.core.generators.exp_creator.ExpCreator` on each
    experimental definition.

    Attributes:
        batch_config_template: Path (relative to current dir or
        absolute) to the root template XML configuration file.

        batch_input_root: Root directory for all generated XML input files all
                          experiments should be stored (relative to current dir
                          or absolute). Each experiment will get a directory
                          within this root to store the xml input files for the
                          experimental runs comprising an experiment; directory
                          name determined by the batch criteria used.

        batch_output_root: Root directory for all experiment outputs (relative
                           to current dir or absolute). Each experiment will get
                           a directory 'exp<n>' in this directory for its
                           outputs.

        criteria: :class:`~sierra.core.variables.batch_criteria.BatchCriteria`
                  derived object instance created from cmdline definition.

    """

    def __init__(self,
                 batch_config_template: str,
                 batch_input_root: str,
                 batch_output_root: str,
                 criteria: bc.BatchCriteria,
                 cmdopts: types.Cmdopts) -> None:

        self.batch_config_template = batch_config_template
        self.batch_config_leaf, _ = os.path.splitext(
            os.path.basename(self.batch_config_template))

        self.batch_input_root = batch_input_root
        self.batch_output_root = batch_output_root
        self.criteria = criteria
        self.cmdopts = cmdopts
        self.logger = logging.getLogger(__name__)

    def create(self, generator: BatchExpDefGenerator) -> None:
        sierra.core.utils.dir_create_checked(self.batch_input_root,
                                             self.cmdopts['exp_overwrite'])

        # Scaffold the batch experiment, creating experiment directories and
        # writing template XML input files for each experiment in the batch with
        # changes from the batch criteria added.
        self.criteria.scaffold_exps(XMLLuigi(self.batch_config_template),
                                    self.batch_config_leaf,
                                    self.cmdopts)

        # Pickle experiment definitions in the actual batch experiment
        # directory for later retrieval.
        self.criteria.pickle_exp_defs(self.cmdopts)

        # Run batch experiment generator (must be after scaffolding so the
        # per-experiment template files are in place).
        defs = generator.generate_defs()

        for i, defi in enumerate(defs):
            self.logger.debug(
                "Applying generated scenario+controller changes to exp%s",
                i)
            exp_output_root = os.path.join(self.batch_output_root,
                                           self.criteria.gen_exp_dirnames(self.cmdopts)[i])
            exp_input_root = os.path.join(self.batch_input_root,
                                          self.criteria.gen_exp_dirnames(self.cmdopts)[i])

            ExpCreator(self.batch_config_template,
                       exp_input_root,
                       exp_output_root,
                       self.cmdopts).from_def(defi)


__api__ = [
    'ExpCreator',
    'BatchExpCreator',
]
