#
# Copyright 2024 John Harwell, All rights reserved.
#
# SPDX-License Identifier: MIT
#
"""Inter-experiment linegraph generation in stage 4."""

# Core packages
import typing as tp
import logging

# 3rd party packages
import json

# Project packages
from sierra.core import types, batchroot, graphs
from sierra.core.variables import batch_criteria as bc

_logger = logging.getLogger(__name__)


def generate(
    cmdopts: types.Cmdopts,
    pathset: batchroot.PathSet,
    targets: tp.List[types.YAMLDict],
    criteria: bc.IConcreteBatchCriteria,
) -> None:
    """Generate linegraphs from :term:`Collated Output Data` files.

    The graphs generated by this module respect the ``--exp-range`` cmdline
    option.
    """

    _logger.info("LineGraphs from %s", pathset.stat_collate_root)

    # For each category of linegraphs we are generating
    for category in targets:

        # For each graph in each category
        for graph in category:
            if graph["type"] not in ["summary_line", "stacked_line"]:
                continue

            _logger.trace("\n" + json.dumps(graph, indent=4))  # type: ignore

            if graph["type"] == "summary_line":
                _gen_summary_linegraph(graph, pathset, cmdopts, criteria)
            elif graph["type"] == "stacked_line":
                _gen_stacked_linegraph(graph, pathset, cmdopts, criteria)


def _gen_summary_linegraph(
    graph: types.YAMLDict,
    pathset: batchroot.PathSet,
    cmdopts: types.Cmdopts,
    criteria: bc.IConcreteBatchCriteria,
) -> None:
    legend = "{0}+{1}".format(cmdopts["controller"], cmdopts["scenario"])

    paths = graphs.PathSet(
        input_root=pathset.stat_collate_root,
        output_root=pathset.graph_collate_root,
        batchroot=pathset.root,
        model_root=None,
    )

    # 2025-06-05 [JRH]: We always write stage {3,4} output data files as .csv
    # because that is currently SIERRA's 'native' format; this may change in the
    # future.
    graphs.summary_line(
        paths=paths,
        input_stem=graph["dest_stem"],
        output_stem=graph["dest_stem"],
        medium="storage.csv",
        legend=[legend],
        stats=cmdopts["dist_stats"],
        title=graph["title"],
        xlabel=criteria.graph_xlabel(cmdopts),
        ylabel=graph.get("ylabel", None),
        xticks=criteria.graph_xticks(cmdopts, pathset.output_root),
        xticklabels=criteria.graph_xticklabels(cmdopts, pathset.output_root),
        logyscale=cmdopts["plot_log_yscale"],
        large_text=cmdopts["plot_large_text"],
    )


def _gen_stacked_linegraph(
    graph: types.YAMLDict,
    pathset: batchroot.PathSet,
    cmdopts: types.Cmdopts,
    criteria: bc.IConcreteBatchCriteria,
) -> None:

    paths = graphs.PathSet(
        input_root=pathset.stat_collate_root,
        output_root=pathset.graph_collate_root,
        model_root=None,
        batchroot=pathset.root,
    )
    graphs.stacked_line(
        paths=paths,
        input_stem=graph["dest_stem"],
        output_stem=graph["dest_stem"],
        stats=cmdopts["dist_stats"],
        medium="storage.csv",
        title=graph["title"],
        xlabel=graph.get("xlabel", "Time"),
        ylabel=graph.get("ylabel", None),
        logyscale=cmdopts["plot_log_yscale"],
        large_text=cmdopts["plot_large_text"],
        legend=graph.get("legend", [f"exp{i}" for i in range(0, criteria.n_exp())]),
    )


__all__ = ["generate"]
